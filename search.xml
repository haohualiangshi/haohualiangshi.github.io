<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[note_taking_01]]></title>
    <url>%2F2017%2F07%2F10%2Fnote-taking-01%2F</url>
    <content type="text"><![CDATA[关于blob类型的理解想下载一个视频时发现是个blob:src形式；不明白这个是个什么鬼，以下是搜索学习的总结 参考网址：https://creamidea.github.io/static/html/articles/HTML5-Video-Blob.html 。先来段代码熟悉下意思 12345678910111213var video=document.querySelector('video');var mediaSource=new MdeiaSource;video.Src=URL.createObjectURL(mediaSource);mediaSource.addEventListener('sourceopen',sourceOpen);function sourceOpen()&#123; var mediaSource=this; var sourceBuffer = mediaSource.addSourceBuffer('video/mp4';codecs="avc1.42E01E,mp4a.40.2");sourceBuffer.addEventListener('updateend',function()&#123; mediaSource.endOfStream(); video.play();&#125;)sourceBuffer.appendBuffer(buf);// buf is the arraybuffer to store the video data&#125; 代码解析：创建变量名为video的DOM对象，创建变量名为mediaSource的MediaSource对象。通过函数createObjectURL将video对象的src和mediaSource进行连接，然后通过注册事件event::sourceopen来触发当前连接之后的的回调处理；回调处理就是需要赋值视频数据的地方，调用MediaSourceBuffer::addSourceBuffer方法来构建一个存放视频数据的Buffer；在往buffer中存放数据结束后触发事件updateend。然后调用play函数通知浏览器播放视频 MediaSource :mediaSource是Media Source Extensions API表示媒体资源HTMLMediaElement对象的接口。MediaSource对象可以附着在HTMLMediaElement在客户端进行播放。参考网址：https://developer.mozilla.org/zh-CN/docs/Web/API/MediaSource MediaSource属性： MediaSource.sourceBuffers:只读 ，返回一个SourceBufferList对象，包含了SourceBuffer的列表object associated with this MediaSource. MediaSource.activeSourceBuffer:只读 MediaSource.readyState:只读 mediaSource.duration 方法： addSourceBuffer():该事件是在触发sourceopen监听时进行的，该动作会创建一个sourceBuffer对象用于数据流的播放处理。如果mediaSource对象无法触发该事件；则无法通过该扩展进行播放的。 removeSourceBuffer(): endOfStream() MediaSource接口的使用： 参考网址：http://chenzhaofei.lofter.com/post/1d03c1b7_58d8a79 判断是否mediaSource的扩展类，该语句决定了整个播放方式是否可以使用MediaSource接口控制播放器。 1window.MediaSource = window.MediaSource || window.WebkitMediaSource; isTypeSupporteed:判断是否支持要解码播放的视频文件编码和类型。 123MediaSource.isTypeSupported('video/webm;codecs="vorbis,vp8"');//是否支持webmMediaSource.isTypeSupported('video/mp4;codecs="avc1.42E01E,mp4a.40.2"')//是否支持MP4MediaSource.isTypeSupported('video/mp2t;codes="avc1.42E01E,mp4a.40.2"')//是否支持ts addSourceBuffer 1mediaSource.addSourceBuffer('video/mp4;codecs="avc1.42E01E,mp4a.40.2"') appendBuffer:sourceBuffer对象的方法，用于持续数据的添加播放 1sourceBuffer.appendBuffer(Uint8array);//媒体二进制数据 buffered: 类型为TimeRanges，描述了添加进去的所有媒体数据的range信息。为一个数组，里边标示了持续或间断的时间信息列表 1234for(var i=0;i&lt;buffered.length;i++)&#123; start=buffered.start(i)//第i个range信息的开始时间 end=buffered.end(i);//第i个range信息的结束时间&#125; 如果播放的媒体数据是连续的；则只有一个开始时间点和一个结束时间点。所以如果要计算缓冲中还存在多少时间则可以通过该描述信息与当前播放时间点进行换算 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function play()&#123; if(!this.mediaSource)&#123; this.mediaSource=new MediaSource(); var me=this; this.mediaSource.addEventListener("sourceopen",function()&#123; me.onMediaSourceOpen(); &#125;); this.mediaSource.addEventListener("sourceended",function()&#123; me.onMediaSourceEnded(); &#125;); this.mediaSource.addEventListener('sourceclose',function()&#123; me.onMediaSourceClose(); &#125;); this.mediaSource.addEventListener("error",function()&#123; me.onUpdataError(); &#125;); this.video=this.createNewVideo(); this.video.src=window.URL.createObjectURL(this.mediaSource); this.video.play(); &#125; if(!this.sourceBuffer)&#123; return ; &#125; if(this.sourceBuffer.updating)&#123; return;//上一块数据还在添加中 &#125; try&#123; this.sourceBuffer.appendBuffer(dataBytes);//添加数据 &#125;catch(err)&#123;&#125;&#125; function createNewVideo()&#123; var newVideo=document.createElement("video"); newVideo.id="player"; newVideo.width=this.videoWidth; newVideo.height=this.videoHeight; return newVideo; &#125; //事件侦听 onMediaSourceOpen:function()&#123; //DOMString可以通过转码获得 var typeNmae='video/mp4;codecs="avc1.42E01E,mp4a.40.2"'; var issurpport=MediaSource.isTypeSupported(typeName); this.mediaSource.duration=this.totalDuration;//设置视频总时长 this.sourceBuffer=this.mediaSource.addSourceBuffer(typeName); &#125; onMediaSourceEnded:function()&#123; console.log("source ended"); &#125; onMediaSourceClosed:function()&#123; console.log("cource close"); &#125;&#125; 以下是自己做的一个demo；MP4格式的文件未成功；webm格式的成功了；但是不能跨越 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;blob&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;video id=&quot;video&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt; &lt;script type=&quot;text/javascript&quot;&gt; var video = document.querySelector(&apos;video&apos;); var assetURL = &apos;http://172.16.70.106:8020/Demo/Demo1/audio/test2.webm&apos;; // Need to be specific for Blink regarding codecs // ./mp4info frag_bunny.mp4 | grep Codec var mimeCodec = &apos;video/webm;codecs=&quot;vorbis,vp8&quot;&apos;; if(&apos;MediaSource&apos; in window &amp;&amp; MediaSource.isTypeSupported(mimeCodec)) &#123; var mediaSource = new MediaSource(); video.src = URL.createObjectURL(mediaSource); mediaSource.addEventListener(&apos;sourceopen&apos;, sourceOpen); &#125; else &#123; console.error(&apos;Unsupported MIME type or codec: &apos;, mimeCodec); &#125; function sourceOpen() &#123; console.log(this); // open var mediaSource = this; var sourceBuffer = mediaSource.addSourceBuffer(mimeCodec); fetchAB(assetURL, function(buf) &#123; console.log(buf) console.log(sourceBuffer); sourceBuffer.addEventListener(&apos;updateend&apos;, function() &#123; console.log(mediaSource); mediaSource.endOfStream(); video.play(); console.log(mediaSource.readyState); // ended &#125;); sourceBuffer.appendBuffer(buf); &#125;); &#125;; function fetchAB(url, cb) &#123; console.log(url); var xhr = new XMLHttpRequest; xhr.open(&apos;get&apos;, url); xhr.responseType = &apos;arraybuffer&apos;; xhr.onload = function() &#123; console.log(xhr.response); cb(xhr.response); &#125;; xhr.send(); &#125;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 不可跨域]]></content>
      <categories>
        <category>随手笔记</category>
      </categories>
      <tags>
        <tag>blob</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[referenceType_1]]></title>
    <url>%2F2017%2F07%2F06%2FreferenceType-1%2F</url>
    <content type="text"><![CDATA[[TOC] 引用类型在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。对象是某个特定引用功能的实例 object类型创建object实例的方式有两种： 使用new操作符后跟Object构造函数 123var person=new Object();person.name="haohualiangshi";person.age=29; 使用对象字面量的表示方法 1234var person=&#123; name:"haohualiangshi", age:25&#125; 对象字面量是向函数传递大量可选参数的的首选方式 Array类型js中数组的每一项都可以保存不同类型的数据。创建数组的基本方式有两种：使用Array构造函数，使用数组字面量表示法。 数组的存储方式有栈方法和队列方法： 栈是一种LIFO（后进先出）的数据结构，栈的操作方法：push()和pop()方法，push方法可以接收任意数量的参数，把他们逐个添加到数组末尾，并返回修改后的数组长度。而pop方法则从数组末尾移除最后一项；并返回移除的项。 队列方法的访问规则是FIFO（先进先出）；队列是在列表的末端添加；在列表的前端移除项；其操作是用push方法在数组的末尾添加数组项；用shift方法移除数组的第一项并返回该项；另外数组还提供了unshift方法；其作用与shift方法相反；与push类似；在数组的前端添加任意个数组项并返回新的数组长度，使用shift和unshift方法可以从相反的方向模拟队列. 数组中定义好的的重排序方法： reverse() :翻转数组项的顺序 sort() : 默认情况下sort方法是按升序排序的；注意；sort方法比较的是字符串：sort方法会调用每个数组项的toString；然后进行对比。该函数可以通过传递两个参数进行灵活的排序操作：如果第一个参数位于第二个参数之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数位于第二个参数之后，则返回正数。 操作方法： concat()方法可以基于当前数组中的所有项创建一个新的数组，他的参数可以传递一个或者多个 12var colors=["red","green","#888"];colors.concat("#999",["#333","#999"]);//["red", "green", "#888", "#999", "#333", "#999"] slice()方法：它能够基于当前数组的一个或者多个项创建一个新数组。两个参数表示起始位置和结束位置；第二个参数可选 splice()方法：可以完成删除、插入和替换：该方法始终返回一个数组，该数组包含从原始数组中删除的项。无删除项则返回空数组。 删除：需要指定两个参数；要删除的第一项的位置和要删除的项数 12var colors=["red","green","yellow"];colors.splice(0,2);//["red", "green"] 插入：需要提供三个参数，起始位置、删除的项数和插入的任意项数 123var colors=["red","green","yellow"];colors.splice(1,0,"#999","#888");console.log(colors); 替换：可以向指定的位置插入任意数量的项；并指定三个参数：起始位置、要删除的项数和要插入的任意数量的项 位置方法：两个位置方法：indexof()和lastIndexOf()。这两个方法都接收两个参数：要查找的项和表示查找起点位置的索引；其中indexOf()从数组的开头向后查找；lastIndexOf()从数组的末尾向前查找；没有找到则返回-1。 迭代方法：es5定义了5种迭代方法。每个方法接收两个参数：要在每一项上运行的函数和（可选的）运行函数的作用域对象–影响this的值；传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身；以下是五个迭代方法 every():对数组中的每一项运行给定的函数，如果该函数每一项都返回true；则返回true filter():对数组中的每一项运行给定函数；返回该函数会返回true的项组成的数组 forEach():对数组中的每一项运行给定函数，这个方法没有返回值 map()：对数组中的每一项运行给定函数；返回每次函数调用的结果返回的数组 some(): 对数组中的每一项运行给定函数；如果该函数对数组中的任意一项返回true则返回true 12345678910111213141516171819202122var numArr=[1,2,3,4,5,4,3,2,1];var everyResult=numArr.every(function(item,index,array)&#123; return (item&gt;2);&#125;);console.log(everyResult);var someResult=numArr.some(function(item,index,array)&#123; return (item&gt;2);&#125;);console.log(someResult);var filterResult=numArr.filter(function(item,index,array)&#123; return (item&gt;2);&#125;);console.log(filterResult);var mapResult=numArr.map(function(item,index,array)&#123; return (item &gt;2);&#125;)console.log(mapResult);//forEach没有返回值；能够对数组的每一项执行操作numArr.forEach(function(item,index,array)&#123; console.log(item+1);&#125;) es5新增了两个归并方法：reduce()和reduceRight(),这两个方法都会迭代数组的所有项；然后构建一个最终返回的值。reduce()方法从数组的第一项开始；逐个便利到最后；而reduceRight()则从数组的最后一项开始；逐个便利到第一项。这两个方法都接收两个参数：一个在每一项上调用的函数和可做为归并基础的初始值（可选） 12345678910var reduceArr=[1,2,3,4,5];reduceArr.reduce(function(prev,cur,index,array)&#123; //四个参数分别是前一个结果值、当前值、项的索引和数组对象 console.log(cur); return prev+cur;&#125;);reduceArr.reduceRight(function(prev,cur,index,array)&#123; console.log(cur); return prev+cur;&#125;) Date类型通过new Date()来获取当前的时间的字符串；如果要获取特定日期；需要传入表示该日期的毫秒数‘为例；为了简化过程；js提供了两个方法Date.parse()和Date.UTC(); Date.parse()方法接收一个表示日期的字符串参数；然后尝试根据字符串返回对应的毫秒数；解析不成功则返回NaN ES5中添加了Date.now()方法；返回调用该方法时日期和时间的毫秒数；日期做比较时调用valueof方法；日期比较的是毫秒数 Function类型函数其实是对象；每个函数都是Function类型的实例，因此函数名实际上也是指向函数对象的指针。函数声明和函数表达式是有区别的：函数声明在解析时会提升；函数表达式则不会；必须先定义后使用 在函数内部有两个特殊的对象：arguments和this arguments拥有一个callee的属性，该属性是个指针，指向拥有这个arguments对象的函数，在非严格模式下使用，例如函数阶乘 12345678function factorial(num)&#123; if(num&lt;=1)&#123; return 1 &#125;else&#123; return num*arguments.callee(num-1); &#125;&#125;factorial(5);//120 函数的另外一个对象是this：this引用的是函数据以执行的环境对象（在网页的全局作用域中调用函数时this对象引用的就是不window对象 在非严格模式下es5规范化了另外一个函数对象的属性：caller属性保存着当前函数的函数的引用；如果在全局作用域中调用当前函数；他的值为null;在严格模式下使用caller或者arguments.callee.caller都会造成错误 123456789"use strict"function outer()&#123; inner(); console.log(outer.caller);&#125;function inner()&#123; alert(arguments.callee.caller);//指向函数outer&#125;outer(); 函数还具有length和prototype属性：length属性表示形参的个数，prototype属性是保存他们所有实例方法的真正所在，该属性不可枚举 每个函数都包含两个非继承而来的方法：apply()和call()，这两个方法的用途是在特定的作用域中调用函数；并能扩展函数的作用域 12345678window.color="red";var o=&#123;color:"blue"&#125;;function sayColor()&#123; console.log(this.color);&#125;sayColor.call(this);sayColor.call(o);sayColor.call(window); es5还定义了bind()方法;该方法会创建一个函数的实例；其this值会被绑定到传给bind()函数的值 123456var color="red";var o=&#123;color:"blue"&#125;;function sayColor()&#123; console.log(this.color);&#125;var objectColor=sayColor.bind(o); 基本包装类型为了便于操作基本类型的值；js引入了三个特殊的引用类型；Boolean、Number和String。 Number类型提供了一些用于将数值格式化为字符串的方法： toFixed()方法会按照指定的小数位返回数值的字符串表示,该方法具有自动舍入的特性 12var num=10.005;console.log(num.toFixed(2));//10.01 toExponential()方法；该方法返回指数表示法；表示数值的字符串形式;接收一个参数用来表示小数位 12var num=19;console.log(num.toExponential(2)) toPrecision()可以根据参数的不同用恰当的字符串来表示数值 1234var num=99;console.log(num.toPrecision(1));console.log(num.toPrecision(2));console.log(num.toPrecision(3)); String类型String对象的属性和方法也可以在所有的字符串中访问，string类型的每个实例都有length属性，表示字符串包含多少个字符 charAt()和charCodeAt();这两个方法都接收一个表示字符索引位置的参数；charAt()返回给定位置的那个字符。charCodeAt()返回的是索引位置对应的编码 123var test="hello";console.log(test.charAt(2));//"l"console.log(test.charCodeAt(2))//108 concat()方法的作用同数组的concat方法相同，用于将一个或者多个字符串拼接起来，返回得到的新字符串； 基于子字符串创建新字符串的三个方法：slice()、substr()和substring();这三个方法都返回被操作字符串的子字符串，接收一个或者两个参数。第二个参数的区别是slice()和substring()指定的是字符串最后一个字符后边的位置(包头不包尾)。而substring()的第二个参数指定的则是返回字符的个数;如果不传第二个参数则默认截取到最后。这三个方法都对原始字符串无影响 这三个方法都是可以传入负值的；对负值的解析也不相同：slice()方法会将传入的负值与长度相加，substr()会将负值的第一个参数与长度相加；第二个参数转为0，substring会将所有的负值转为0 1234var test="this is a test string";console.log(test.substring(1,3));//hiconsole.log(test.slice(1,3));//hiconsole.log(test.substr(1,3));//his indexOf()和lastIndexOf();从一个字符串中搜寻给定的字符串，然后返回给定字符串的位置；没找到则返回-1 trim()方法；这个方法创建一个字符串的副本，删除前置以及后置的所有空格并返回结果 字符串的大小写转换：js中有四个涉及大小写转换的方法：toLowerCase()、toLocaleLowerCase()、toUpperCase()、toLocalUpperCase() 字符串的模式匹配方法 match()方法，在字符串上调用这个方法本质上与调用RegExp的exec()方法相同，match方法只接收一个参数，要么是个正则表达式，要么是个RegExp对象 12345var text="cat,bat,sat,fat";var pattern=/.at/;//与 pattern.exec(text)相同var matches=text.match(pattern);console.log(matches);//["cat", index: 0, input: "cat,bat,sat,fat"] search():该方法的唯一参数与match()相同；返回字符串中第一个匹配项的索引；未找到则返回-1 replace()方法：该方法接收两个参数，第一个参数可以是正则表达式或者一个字符串，第二个参数可以是个字符串或者函数 123456var text="cat,bat,sat,fat";var result=text.replace("at","ond");console.log(result);//cond,bat,sat,fat//替换所有需要使用正则的全局标志result=text.replace(/at/g,"ond");console.log(result);//cond,bond,sond,fond split()方法：这个方法可以基于指定的分割符将一个字符串分割成多个字符串，并将结果放在数组中；该方法可以接收第二个参数用于截取数组的长度。 localeCompare()方法：这个方法比较两个字符串，并返回下列值中的一个 如果字符串在字母表中应该排在字符串参数之前，则返回一个负数 如果字符串等于字符串参数，则返回0 如果字符串在字母表中的位置排在字符串参数之后，返回一个正数 1234var stringValue="yellow";console.log(stringValue.localeCompare("brick"));//1console.log(stringValue.localeCompare("yellow"));//0console.log(stringValue.localeCompare("zoo"));//-1 ​]]></content>
      <categories>
        <category>js教程总结</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>引用类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es5-ver2.md]]></title>
    <url>%2F2017%2F07%2F05%2Fes5-ver2-md%2F</url>
    <content type="text"><![CDATA[变量的操作 在使用引用类型操作时；js不允许直接访问内存的的位置，也就是说不能直接操作对象的内存空间，在操作对象时是操作的对象的引用 复制基本类型的变量值时；会在变量对象上创建一个新值；然后把该值复制到新变量分配的位置上 复制引用类型时：其实是复制的副本的一个指针，该指针的指向与复制对象的指向相同 函数的参数都是按值传递的；即把函数外部的值复制给函数内部的参数；函数的参数其实就是函数的内部变量； 变量的检测：基本类型的变量用typeof来检测类型；引用类型的需要使用instanceof来判断是不是一个对象的实例；基本类型的变量使用instanceof返回false； 执行环境和作用域执行环境定义了变量或者函数有权访问的其他数据，每一个执行环境都有一个与之关联的变量对象 ；当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链保证了对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端始终是当前执行代码所在环境的变量对象；如果执行环境是个函数，则将其活动对象作为变量对象，活动对象最开始只包括一个变量，即arguments对象。 作用域链中的下一个对象来自包含（外部）环境，再下一个变量对象怎来自下一个包含环境；一直延续到全局执行环境；全局执行环境的对象始终都是作用域链的最后一个对象。 123456789101112var color="blue";function changeColors()&#123; var anotherColor="red"; function swapColors()&#123; var tempColor=anotherColor; anotherColor=color; color=tempColor; //三个变量都能访问到 &#125; //能访问两个变量&#125;//只能访问全局变量 内部函数可以通过作用域链访问外部函数的变量对象 声明变量：使用var声明的变量会自动添加到最接近的环境中；如果再使用变量前未声明；该变量会被自动添加到全局环境；严格模式下初始化未声明的变量会报错。]]></content>
      <categories>
        <category>js教程总结</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>变量</tag>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es5-ver]]></title>
    <url>%2F2017%2F07%2F04%2Fes5-ver%2F</url>
    <content type="text"><![CDATA[变量、作用域变量 js的变量是松散类型的，即可以用来保存任何类型的数据 变量分为5种基本数据类型和1种复杂类型的： 基本类型：Undefined、Null、Boolean、Number和String 复杂类型：Object，Object本质上是由一组无序的名值对组成 在es 5中是可以使用typeof操作符进行数据类型的检测，其返回值：undefined、boolean、string、number、object、function。 在使用数值转换时的三种方法 Number()函数的转换规则，在传入值不同下返回; boolean值的true和false直接转换为1和0 数值直接返回传入值 null值返回0 undefined返回NaN 字符串： 字符串全为数字；将该字符串转为十进制；eg;”123”转为123，“0123”转为123 如果字符串包含浮点格式“1.5”转为浮点值1.5，同样忽略前边的0；但是如果不是标准的浮点格式；会转为NaN; 如果字符串是标准的十六进制格式“0xaf”则转为十进制175 字符串为空转为0 其他不符合该规则的字符串转为NaN 对象：传入值是对象先调用valueof()方法；依照上述规则转换 parseInt()函数容错比Number函数高；解析时如果第一个字符不是数字或者正负号，该函数会返回一个NaN，该函数第二个参数用来表示装换时使用的基数 parseFloat()函数在在解析一个没有小数点或者小数点后全为零的字符点时返回的是个整数； 字符串生成后时不可变的；null和undefined不具有toString()方法。可以使用String()方法；在数值调用toString方法可以传参数用来指定在转换时的基数； js中的对象其实就是一组数据和功能的集合：object的每个实例都具有下列属性和方法 constructor：保存着用于创建当前对象的函数 hasOwnProperty(propertyName)用于检测给定的属性在当前实例对象中是否存在；而不是在实例的原型中 isPrototypeOf(object):用于检查传入的对象是否是当前对象的原型； toLocaleString() toString() valueOf() 操作符 一元操作符：有前置型和后置型；这4个操作符对任何值都适用 逻辑非操作符(!)：遵循规则 操作数是对象；返回false 操作数的空字符串返回true 非空字符串返回false 0返回true；非0数值返回false null、undefined、NaN返回true 逻辑与(&amp;&amp;)，具有短路效应，即第一个操作数能够决定结果，那么不会对第二个操作数求值；逻辑与操作可以应用任何类型的操作数；而不仅仅是一个布尔值；在有一个操作数不是布尔值的情况下；逻辑与的返回值不一定是布尔值；遵循规则如下： 第一个操作数是对象；返回第二个操作数 在第一个操作数逻辑值为true时返回第二个操作数，否则返回第一个操作数 逻辑或(||),逻辑或也是短路操作符，第一个操作数为true就不会对第二个操作数求值；如果有一个操作数不是布尔值，那么逻辑或也不一定返回布尔值 关系操作符：关系操作符分为小于(&lt;)、大于、小于等于、大于等于，在使用关系操作符时注意隐式转换 数值的优先级比较高；如果一个操作数是字符串或者布尔值和一个数值比较；则先将字符串转为数值，注意：该转换方法调用的是Number()方法；然后进行比较；如果一个操作数是对象，则先调用valueof方法，没有valueof方法则调用toString方法 当两个操作数都是都是字符串；则表两个字符中对应位置的字符的字符编码值 任何操作数与NaN比较都是false 相等操作符：相等和不相等、全等和不全等 相等和不相等是先转换再比较，，称为强制转型 ，其规则与比较运算符区别如下 null和undefined相等，如果两个操作数都是对象；则比较这两个对象是不是指向的同一个对象 全等和不全等（===、!==）不转换就进行比较，类型和值全部相等才返回true 函数函数的参数在内部是用一个伪数组arguments表示的；函数的length属性是表示形参的个数；arguments.length表示实参的个数；在js中函数没有才重载；函数在未指定返回值的情况下默认返回undefined]]></content>
      <categories>
        <category>js教程总结</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>变量</tag>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blogOfHexo]]></title>
    <url>%2F2017%2F06%2F30%2FblogOfHexo%2F</url>
    <content type="text"><![CDATA[博客搭建教程 参考链接：https://smartbeng.github.io/2017/03/26/blogFinish/ 安装Node.js\Git。并在git上创建仓库：https://github.com/haohualiangshi/haohualiangshi.github.io，要求仓库名必须和用户名相同。即必须是userName.github.io;我的userName是haohualiangshi 安装Hexo工具 在任意盘创建Hexo文件（必须是Hexo文件命名）；在Hexo文件夹的父级打开git命令行；运行$ npm install -g hexo; 打开Hexo文件夹；运行hexo init 运行hexo g用来生成页面；运行heox s启动本地服务 hexo 常用命令 hexo new page &quot;pageName&quot;新建文件夹。自动生成在source目录下 hexo new &quot;postName&quot;新建md文件；在source下的_post目录下； hexo运行的命令生成的页面文件是放在public文件夹下；新建一个文件夹用来往github上推送本地的文件。eg:我本地新建的是.deploy文件夹；克隆仓库文件,在hexo目录下运行git clone https://github.com/haohualiangshi/haohualiangshi.github.io .deploy/storm.git.github.io或者打开storm.git.github.io文件夹直接执行复制指令 123456hexo cleanhexo generatecp -R public/* .deploy/storm.github.iogit add .git commit -m &quot;update&quot;git push origin master -u 将上边文件类型命名为.sh文件类型；点击之后自动完成写入的指令完成上传；代码的意思：清除缓存、生成静态文件、将静态文件中的所有文件复制到.deploy/storm.github.io文件夹下、完成git的添加上传； 关于主题的更换网上的文件比较多；我使用的是next主题；参考的教程http://theme-next.iissnan.com/getting-started.html]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown_and_typora]]></title>
    <url>%2F2017%2F06%2F29%2Fmarkdown-and-typora%2F</url>
    <content type="text"><![CDATA[Typora For Markdown语法typora编辑器使用指南Typora是一个功能强大的Markdown编辑器； 数学表达式使用$符号包裹tex命令，例如：$lim_{x \to \infty} \ exp(-x)=0$将产生如下表达式： $lim_{x \to \infty} \ exp(-x)=0$ 下标下标使用~包裹，例如：$H~2~O$将生成水的表达式（注意：要使用$包裹）$H~2~O$ 上标使用^包裹；例如：$y^2=4$将产生表达式:$y^2=4$ 插入表情使用:happy:输出高兴的表情:happy:，使用:sad:输入悲伤的表情，以此类推； 下划线用html的语法&lt;u&gt;underline&lt;/u&gt;将产生下划线underline 删除线使用~~包裹的文本将会具有删除的样式；例如：~~删除的文本~~将产生删除的文本样式 代码代码分为行内插入和代码块 行内插入代码：使用`包裹的内容将会以代码的形式显示 代码块：输入三个~或三个`号然以后回车就可以输入代码块；并且可以选择代码的语言 1var a=10; 强调使用两个*号或者两个_包裹的内容将会被强调。例如 12**使用两个*号强调内容**__使用两个下划线强调内容__ 将会输出 使用两个*号强调内容 使用两个下划线强调内容 Typroa推荐使用两个*号 斜体在标准的Markdown语法中，*和_包裹的内容会斜体显示；但是在GFM下划线一般用来分隔人名和代码变量名；因此推荐使用星号来包裹斜体内容。如果要显示星号需要\转义 1&lt;p&gt;\*你好。typora！*&lt;/p&gt; *你好。typora！* 你好。typora！ 插入图片我们可以采用拖拽的方式，将本地文件夹中的I图片或者网络上的图片插图 插入URL连接使用尖括号包裹的URL将产生一个连接；例如：&lt;http://www.baidu.com&gt;将产生连接: http://www.baidu.com;网址要写标准；否则可能不会显示 目录列表Table of Content(toc)输入[toc]然后回车，会产生一个目录，这个目录抽取了文章的所有标题；自动更新内容。(目录不能跨级；可能是造成页面生成目录失败的原因，下期验证) 水平分割线使用三个*或者三个-，然后回车，来产生水平分割线。 标注我们可以对某一词语进行标注。例如 12某些人用过了才知道[^1][^1]：这个是注释的内容 注释的编号需要相同 某些人用过了才知道^1 表格12345|姓名|性别|毕业院校|工资||:---|:---:|:---:|---:|(注意顿号的位置表示对齐方式)|洋洋|男|重庆交通大学|3200||峰哥|男|河南大学|4000||坑会|男|河南科技学院|3000| 将会产生 姓名 性别 毕业院校 工资 洋洋 男 重庆交通大学 3200 峰哥 男 河南大学 4000 坑会 男 河南科技学院 3000 数学表达式块输入两个美元符号；然后回车就可以输入数学表达式。例如： 1$$\mathbf&#123;V&#125;_1 \times \mathbf&#123;V&#125;_2 = \begin&#123;vmatrix&#125; \mathbf&#123;i&#125; &amp; \mathbf&#123;j&#125; &amp; \mathbf&#123;k&#125; \\\frac&#123;\partial X&#125;&#123;\partial u&#125; &amp; \frac&#123;\partial Y&#125;&#123;\partial u&#125; &amp; 0 \\\frac&#123;\partial X&#125;&#123;\partial v&#125; &amp; \frac&#123;\partial Y&#125;&#123;\partial v&#125; &amp; 0 \\\end&#123;vmatrix&#125;$$ $$\mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \\frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \\end{vmatrix}$$ 任务列表我们可以选择有没有完成；在[]中填入x表示完成；也可以通过点击选择完成或者没完成； -[ ]和-[x]两种方式 -[ ] 吃饭 列表输入+，-，*，创建无序的列表；使用任意字母开头创建有序的列表 1234**无序列表*** 你好- 二货+ 成功 无序列表 你好 二货 成功 nihao fsadf dfs fasdf 块引用使用&gt;来插入块引用。例如： 这个是块引用 标题是用#的个数表示标题;有6个标题]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>markdown</tag>
        <tag>typora</tag>
      </tags>
  </entry>
</search>